var p=Object.defineProperty;var C=(l,t,s)=>t in l?p(l,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):l[t]=s;var o=(l,t,s)=>(C(l,typeof t!="symbol"?t+"":t,s),s);import{s as u,C as M,U as v,A as r,B as m,T as b,i as w,O as S,a as j}from"./needle-engine-001a697c.js";import{O as y,R as T}from"./three.module-9d0655ba.js";import"./index-177b97e4.js";var _=Object.defineProperty,B=Object.getOwnPropertyDescriptor,O=(l,t,s,g)=>{for(var i=g>1?void 0:g?B(t,s):t,n=l.length-1,c;n>=0;n--)(c=l[n])&&(i=(g?c(t,s,i):c(i))||i);return g&&i&&_(t,s,i),i};function D(l){l&&(l.getComponentInParent(T)||(w()&&console.warn("Create Raycaster on "+l.name+" because no raycaster was found in the hierarchy"),l.addNewComponent(S)))}var d;const e=(d=class extends M{constructor(){super(...arguments);o(this,"target");o(this,"toggleOnClick",!1);o(this,"targetState",!0);o(this,"hideSelf",!0);o(this,"selfModel");o(this,"selfModelClone");o(this,"targetModel");o(this,"toggleModel");o(this,"stateBeforeCreatingDocument",!1);o(this,"targetStateBeforeCreatingDocument",!1)}start(){D(this.gameObject)}onPointerClick(t){t.use(),!this.toggleOnClick&&this.hideSelf&&(this.gameObject.visible=!1),this.target&&(this.target.visible=this.toggleOnClick?!this.target.visible:this.targetState)}createBehaviours(t,s,g){s.uuid===this.gameObject.uuid&&(this.selfModel=s,this.selfModelClone=s.clone())}beforeCreateDocument(){this.target&&(this.gameObject[e.wasVisible]===void 0&&(this.gameObject[e.wasVisible]=this.gameObject.activeSelf),this.target[e.wasVisible]===void 0&&(this.target[e.wasVisible]=this.target.activeSelf),this.stateBeforeCreatingDocument=this.gameObject[e.wasVisible],this.targetStateBeforeCreatingDocument=this.target[e.wasVisible],this.gameObject.visible=!0,this.target.visible=!0)}afterCreateDocument(t,s){if(!this.target)return;this.targetModel=s.document.findById(this.target.uuid);const g=this.selfModel;if(this.selfModel&&this.targetModel){let i=this.selfModel,n=this.targetState;if(this.toggleOnClick)if(n=!this.targetStateBeforeCreatingDocument,!this.selfModelClone.geometry)(!this.selfModel.parent||this.selfModel.parent.isEmpty())&&v.createEmptyParent(this.selfModel),this.toggleModel=this.selfModel.deepClone(),this.toggleModel.name+="_toggle",this.selfModel.parent.add(this.toggleModel);else{if(!this.gameObject[e.toggleClone]){const a=this.selfModelClone.clone();a.matrix.identity(),a.name+="_toggle"+e.clonedToggleIndex++,g.add(a),this.gameObject[e.toggleClone]=a,console.warn("USDZExport: Toggle "+this.gameObject.name+" doesn't have geometry. It will be deep cloned and nested behaviours will likely not work.")}const h=this.gameObject[e.toggleClone];if(!this.gameObject[e.reverseToggleClone]){const a=this.selfModelClone.clone();a.matrix.identity(),a.name+="_toggleReverse"+e.clonedToggleIndex++,g.add(a),this.gameObject[e.reverseToggleClone]=a}this.toggleModel=this.gameObject[e.reverseToggleClone],(!this.toggleModel.geometry||!h.geometry)&&console.error("triggers without childs and without geometry won't work!",this,g.geometry),i=h,g.geometry=null,g.material=null}if(this.toggleModel){if(this.toggleOnClick){const h=[];h.push(r.fadeAction(i,0,!1)),h.push(r.fadeAction(this.toggleModel,0,!0)),h.push(r.fadeAction(this.targetModel,0,n)),t.addBehavior(new m("Toggle_"+i.name+"_toggleTo"+(n?"On":"Off"),b.tapTrigger(i),r.parallel(...h)));const a=[];a.push(r.fadeAction(this.toggleModel,0,!1)),a.push(r.fadeAction(i,0,!0)),a.push(r.fadeAction(this.targetModel,0,!n)),t.addBehavior(new m("Toggle_"+i.name+"_toggleTo"+(n?"Off":"On"),b.tapTrigger(this.toggleModel),r.parallel(...a)))}}else{const h=[];this.hideSelf&&h.push(r.fadeAction(i,0,!1)),h.push(r.fadeAction(this.targetModel,0,n)),t.addBehavior(new m("Toggle_"+i.name+"_toggleTo"+(n?"On":"Off"),b.tapTrigger(i),r.parallel(...h)))}const c=new Array;this.targetStateBeforeCreatingDocument||c.push(this.targetModel),this.stateBeforeCreatingDocument||c.push(g),this.toggleModel&&c.push(this.toggleModel),t.addBehavior(new m("HideOnStart_"+this.gameObject.name,b.sceneStartTrigger(),r.fadeAction(c,0,!1)))}}afterSerialize(t,s){this.gameObject[e.wasVisible]!==void 0&&(this.gameObject.visible=this.gameObject[e.wasVisible],delete this.gameObject[e.wasVisible]),this.target&&this.target[e.wasVisible]!==void 0&&(this.target.visible=this.target[e.wasVisible],delete this.target[e.wasVisible]),delete this.gameObject[e.toggleClone],delete this.gameObject[e.reverseToggleClone]}},o(d,"clonedToggleIndex",0),o(d,"wasVisible",Symbol("usdz_ObjectSwithcer_wasVisible")),o(d,"toggleClone",Symbol("clone for toggling")),o(d,"reverseToggleClone",Symbol("clone for reverse toggling")),d);let f=e;O([u(y)],f.prototype,"target",2);O([u()],f.prototype,"toggleOnClick",2);O([u()],f.prototype,"targetState",2);O([u()],f.prototype,"hideSelf",2);j.add("ObjectSwithcer",f);
